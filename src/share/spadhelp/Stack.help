====================================================================
Stack examples
====================================================================

A Stack object is represented as a list ordered by last-in, first-out.
It operates like a pile of books, where the "next" book is the one
on the top of the pile.

Here we create a stack of integers from a list. Notice that the
order in the list is the order in the stack.

   a:Stack INT:= stack [1,2,3,4,5]
      [1,2,3,4,5]

We can remove the top of the stack using pop!:

   pop! a
      1

Notice that the use of pop! is destructive (destructive operations
in FriCAS usually end with ! to indicate that the underylying data
structure is changed).

   a
      [2,3,4,5]

The extract! operation is another name for the pop! operation and
has the same effect. This operation treats the stack as a BagAggregate:

   extract! a
      2

and you can see that it also has destructively modified the stack:

   a
      [3,4,5]

Next we push a new element on top of the stack:

   push!(9,a)
      9

Again, the push! operation is destructive so the stack is changed:

   a
      [9,2,3,4,5]

Another name for push! is insert!, which treats the stack as a BagAggregate:

   insert!(8,a)
      [8,9,3,4,5]

and it modifies the stack:

   a
      [8,9,3,4,5]

The inspect function returns the top of the stack without modification,
viewed as a BagAggregate:

   inspect a
      8

The empty? operation returns true only if there are no element on the
stack, otherwise it returns false:

   empty? a
      false

The top operation returns the top of stack without modification, viewed
as a Stack:

   top a
      8

The depth operation returns the number of elements on the stack:

   depth a
      5

which is the same as the # (length) operation:

   #a
       5

The less? predicate will compare the stack length to an integer:

   less?(a,9)
        true

The more? predicate will compare the stack length to an integer:

   more?(a,9)
        false

The size? operation will compare the stack length to an integer:

   size?(a,#a)
        true

and since the last computation must alwasy be true we try:

   size?(a,9)
        false

The parts function will return  the stack as a list of its elements:

   parts a
        [8,9,3,4,5]

If we have a BagAggregate of elements we can use it to construct a stack.
Notice that the elements are pushed in reverse order:

   bag([1,2,3,4,5])$Stack(INT)
        [5,4,3,2,1]

The empty function will construct an empty stack of a given type:

   b:=empty()$(Stack INT)
        []

and the empty? predicate allows us to find out if a stack is empty:

   empty? b
        true

The sample function returns a sample, empty stack:

   sample()$Stack(INT)
        []

We can copy a stack and it does not share storage so subsequent
modifications of the original stack will not affect the copy:

   c:=copy a
        [8,9,3,4,5]

The eq? function is only true if the lists are the same reference,
so even though c is a copy of a, they are not the same:

   eq?(a,c)
        false

However, a clearly shares a reference with itself:

   eq?(a,a)
        true

But we can compare a and c for equality:

   (a=c)@Boolean
        true

and clearly a is equal to itself:

   (a=a)@Boolean
        true

and since a and c are equal, they are clearly NOT not-equal:

   a~=c
        false

We can use the any? function to see if a predicate is true for any element:

   any?(x+->(x=4),a)
        true

or false for every element:

   any?(x+->(x=11),a)
        false

We can use the every? function to check every element satisfies a predicate:

   every?(x+->(x=11),a)
        false

We can count the elements that are equal to an argument of this type:

   count(4,a)
        1

or we can count against a boolean function:

   count(x+->(x>2),a)
        5

You can also map a function over every element, returning a new stack:

   map(x+->x+10,a)
        [18,19,13,14,15]

Notice that the orignal stack is unchanged:

   a
        [8,9,3,4,5]

You can use map! to map a function over every element and change
the original stack since map! is destructive:

   map!(x+->x+10,a)
       [18,19,13,14,15]

Notice that the orignal stack has been changed:

   a
       [18,19,13,14,15]

The member function can also get the element of the stack as a list:

   members a
       [18,19,13,14,15]

and using member? we can test if the stack holds a given element:

   member?(14,a)
       true

See Also:
o )show Stack
o )show ArrayStack
o )show Queue
o )show Dequeue
o )show Heap
o )show BagAggregate

