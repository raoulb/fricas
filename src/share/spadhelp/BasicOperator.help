====================================================================
BasicOperator examples
====================================================================

A basic operator is an object that can be symbolically applied to a
list of arguments from a set, the result being a kernel over that set
or an expression.  

You create an object of type BasicOperator by using the operator
operation.  This first form of this operation has one argument and it
must be a symbol.  The symbol should be quoted in case the name has
been used as an identifier to which a value has been assigned.

A frequent application of BasicOperator is the creation of an operator
to represent the unknown function when solving a differential equation.

Let y be the unknown function in terms of x.

  y := operator 'y
   y 
                      Type: BasicOperator

This is how you enter the equation y'' + y' + y = 0.

  deq := D(y x, x, 2) + D(y x, x) + y x = 0
    ,,       ,
   y  (x) + y (x) + y(x) = 0
                      Type: Equation Expression Integer

To solve the above equation, enter this.

  solve(deq, y, x)
                                        x     x
                                +-+   - -   - -      +-+
                              x\|3      2     2    x\|3
   [particular= 0,basis= [cos(-----)%e   ,%e   sin(-----)]]
                                2                    2
                      Type: Union(Record(particular: Expression Integer,
                                  basis: List Expression Integer),...)

Use the single argument form of BasicOperator (as above) when you
intend to use the operator to create functional expressions with an
arbitrary number of arguments

Nary means an arbitrary number of arguments can be used in the
functional expressions.

  nary? y
   true
                      Type: Boolean

  unary? y
   false
                      Type: Boolean

Use the two-argument form when you want to restrict the number of
arguments in the functional expressions created with the operator.

This operator can only be used to create functional expressions
with one argument.

  opOne := operator('opOne, 1)
   opOne 
                      Type: BasicOperator

  nary? opOne
   false
                      Type: Boolean

  unary? opOne
   true
                      Type: Boolean

Use arity to learn the number of arguments that can be used.  It
returns "false" if the operator is nary.

  arity opOne
   1
                      Type: Union(NonNegativeInteger,...)

Use name to learn the name of an operator.

  name opOne
   opOne 
                      Type: Symbol

Use is? to learn if an operator has a particular name.

  is?(opOne, 'z2)
   false
                      Type: Boolean

You can also use a string as the name to be tested against.

  is?(opOne, "opOne")
   true
                      Type: Boolean

You can attached named properties to an operator.  These are rarely
used at the top-level of the FriCAS interactive environment but are
used with FriCAS library source code.

By default, an operator has no properties.

  properties y
   table() 
                      Type: AssociationList(String,None)

The interface for setting and getting properties is somewhat awkward
because the property values are stored as values of type None.

Attach a property by using setProperty.

  setProperty(y, "use", "unknown function" :: None )
   y 
                      Type: BasicOperator

  properties y
   table("use"=NONE)
                      Type: AssociationList(String,None)

We know the property value has type String.

  property(y, "use") :: None pretend String
   "unknown function"
                      Type: String

Use deleteProperty! to destructively remove a property.

 deleteProperty!(y, "use")
  y 
                      Type: BasicOperator

  properties y
   table() 
                      Type: AssociationList(String,None)


See Also
o )help Expression
o )help Kernel
o )show BasicOperator

