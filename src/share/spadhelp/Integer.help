====================================================================
Integer examples
====================================================================

FriCAS provides many operations for manipulating arbitrary precision
integers.  In this section we will show some of those that come from
Integer itself plus some that are implemented in other packages.

\subsection{Basic Functions}

The size of an integer in FriCAS is only limited by the amount of
computer storage you have available.  The usual arithmetic operations
are available.

  2**(5678 - 4856 + 2 * 17)
  4804810770435008147181540925125924391239526139871682263473855610088084200076_
   308293086342527091412083743074572278211496076276922026433435687527334980249_
   539302425425230458177649495442143929053063884787051467457680738771416988598_
   15495632935288783334250628775936
                        Type: PositiveInteger

There are a number of ways of working with the sign of an integer.
Let's use this x as an example.

  x := -101
    - 101
                        Type: Integer

First of all, there is the absolute value function.

  abs(x)
    101
                        Type: PositiveInteger

The sign operation returns -1 if its argument is negative, 0 if zero
and 1 if positive.

  sign(x)
    - 1
                        Type: Integer

You can determine if an integer is negative in several other ways.

  x < 0
    true
                        Type: Boolean

  x <= -1
    true
                        Type: Boolean

  negative?(x)
    true
                        Type: Boolean

Similarly, you can find out if it is positive.

  x > 0
    false
                        Type: Boolean

  x >= 1
    false
                        Type: Boolean

  positive?(x)
    false
                        Type: Boolean

This is the recommended way of determining whether an integer is zero.

  zero?(x)
    false
                        Type: Boolean

Use the zero? operation whenever you are testing any mathematical
object for equality with zero.  This is usually more efficient that
using = (think of matrices: it is easier to tell if a matrix is zero
by just checking term by term than constructing another "zero" matrix
and comparing the two matrices term by term) and also avoids the
problem that = is usually used for creating equations.

This is the recommended way of determining whether an integer is equal
to one.

  one?(x)
    false
                       Type: Boolean

This syntax is used to test equality using =.  It says that you want a
Boolean (true or false) answer rather than an equation.

  (x = -101)@Boolean
    true
                       Type: Boolean

The operations odd? and even? determine whether an integer is odd or
even, respectively.  They each return a Boolean object.

  odd?(x)
    true
                       Type: Boolean

  even?(x)
    false
                       Type: Boolean

The operation gcd computes the greatest common divisor of two integers.

  gcd(56788,43688)
    4
                       Type: PositiveInteger

The operation lcm computes their least common multiple.

  lcm(56788,43688)
    620238536
                       Type: PositiveInteger

To determine the maximum of two integers, use max.

  max(678,567)
    678
                       Type: PositiveInteger

To determine the minimum, use min.

  min(678,567)
    567
                       Type: PositiveInteger

The reduce operation is used to extend binary operations to more
than two arguments.  For example, you can use reduce to find the
maximum integer in a list or compute the least common multiple of all
integers in the list.

  reduce(max,[2,45,-89,78,100,-45])
    100
                       Type: PositiveInteger

  reduce(min,[2,45,-89,78,100,-45])
    - 89
                       Type: Integer

  reduce(gcd,[2,45,-89,78,100,-45])
    1
                       Type: PositiveInteger

  reduce(lcm,[2,45,-89,78,100,-45])
    1041300
                       Type: PositiveInteger

The infix operator "/" is not used to compute the quotient of integers.  
Rather, it is used to create rational numbers as described in Fraction.

  13 / 4
     13
     --
      4
                       Type: Fraction Integer

The infix operation quo computes the integer quotient.

  13 quo 4
    3
                       Type: PositiveInteger

The infix operation rem computes the integer remainder.

  13 rem 4
    1
                       Type: PositiveInteger

One integer is evenly divisible by another if the remainder is zero.
The operation exquo can also be used.  

  zero?(167604736446952 rem 2003644)
    true
                       Type: Boolean

The operation divide returns a record of the quotient and remainder
and thus is more efficient when both are needed.

  d := divide(13,4)
    [quotient= 3,remainder= 1]
                       Type: Record(quotient: Integer,remainder: Integer)

  d.quotient
    3
                       Type: PositiveInteger

See help on Records for details on Records.

  d.remainder
    1
                       Type: PositiveInteger

====================================================================
Primes and Factorization
====================================================================

Use the operation factor to factor integers.  It returns an object of
type Factored Integer.

  factor 102400
     12 2
    2  5
                       Type: Factored Integer

The operation prime? returns true or false depending on whether its
argument is a prime.

  prime? 7
    true
                       Type: Boolean

  prime? 8
    false
                       Type: Boolean

The operation nextPrime returns the least prime number greater than
its argument.

  nextPrime 100
    101
                       Type: PositiveInteger

The operation prevPrime returns the greatest prime number less than
its argument.

  prevPrime 100
    97
                       Type: PositiveInteger

To compute all primes between two integers (inclusively), use the
operation primes.

  primes(100,175)
    [173,167,163,157,151,149,139,137,131,127,113,109,107,103,101]
                       Type: List Integer

You might sometimes want to see the factorization of an integer
when it is considered a Gaussian integer.

  factor(2 :: Complex Integer)
                 2
    - %i (1 + %i)
                       Type: Factored Complex Integer

====================================================================
Some Number Theoretic Functions
====================================================================

FriCAS provides several number theoretic operations for integers.

The operation fibonacci computes the Fibonacci numbers.  The algorithm 
has running time O(log^3n) for argument n.

  [fibonacci(k) for k in 0..]
    [0,1,1,2,3,5,8,13,21,34,...]
                      Type: Stream Integer

The operation legendre computes the Legendre symbol for its two integer 
arguments where the second one is prime.  If you know the second argument 
to be prime, use jacobi instead where no check is made.

  [legendre(i,11) for i in 0..10]
    [0,1,- 1,1,1,1,- 1,- 1,- 1,1,- 1]
                      Type: List Integer

The operation jacobi computes the Jacobi symbol for its two integer 
arguments.  By convention, 0 is returned if the greatest common divisor 
of the numerator and denominator is not 1.

  [jacobi(i,15) for i in 0..9]
    [0,1,1,0,1,0,0,- 1,1,0]
                      Type: List Integer

The operation eulerPhi computes the values of Euler's \phi-function 
where \phi(n) equals the number of positive integers less than or equal 
to n that are relatively prime to the positive integer n.

  [eulerPhi i for i in 1..]
    [1,1,2,2,4,2,6,4,6,4,...]
                      Type: Stream Integer

The operation moebiusMu computes the Moebius mu function.

  [moebiusMu i for i in 1..]
    [1,- 1,- 1,0,- 1,1,- 1,0,0,1,...]
                      Type: Stream Integer


See Also:
o )help Complex
o )help Factored
o )help Records
o )help Fraction
o )help RadixExpansion
o )help HexadecimalExpansion
o )help BinaryExpansion
o )help DecimalExpansion
o )help IntegerNumberTheoryFunctions
o )help RomanNumeral
o )show Integer

