)abbrev package SORTPAK SortPackage
++ Description:
++ This package exports sorting algorithnms
SortPackage(S, A) : Exports == Implementation where
  S : Type
  A : Join(IndexedAggregate(Integer, S), finiteAggregate, shallowlyMutable)

  NNI ==> NonNegativeInteger

  Exports == with
    bubbleSort! : (A, (S, S) -> Boolean) -> A
        ++ bubbleSort!(a, f) \undocumented

    countingBubbleSort : (A, (S, S) -> Boolean) -> Record(sorted:A, exchanges:NNI)
        ++ Counting version of bubble sort

    countingBubbleSort! : (A, (S, S) -> Boolean) -> Record(sorted:A, exchanges:NNI)
        ++ Counting version of bubble sort

    insertionSort! : (A, (S, S) -> Boolean) -> A
        ++ insertionSort!(a, f) \undocumented

    if A has UnaryRecursiveAggregate(S) then
      mergeSort : (A, (S, S) -> Boolean) -> A
        ++ merge sort

    if S has OrderedSet then
      bubbleSort! : A -> A
        ++ bubbleSort!(a) \undocumented

      countingBubbleSort : A -> Record(sorted:A, exchanges:NNI)
        ++ Counting version of bubble sort

      countingBubbleSort! : A -> Record(sorted:A, exchanges:NNI)
        ++ Counting version of bubble sort

      insertionSort! : A -> A
        ++ insertionSort! \undocumented

      if A has UnaryRecursiveAggregate(S) then
        mergeSort : A -> A
          ++ merge sort

  Implementation == add

    bubbleSort!(m, f) ==
      n := #m
      for i in 1..(n-1) repeat
        for j in n..(i+1) by -1 repeat
          if f(m.j, m.(j-1)) then swap!(m, j, j-1)
      m

    insertionSort!(m, f) ==
      for i in 2..#m repeat
        j := i
        while j > 1 and f(m.j, m.(j-1)) repeat
          swap!(m, j, j-1)
          j := qcoerce(j - 1)@PositiveInteger
      m

    countingBubbleSort(m, f) ==
      countingBubbleSort!(copy m, f)

    countingBubbleSort!(m, f) ==
      wasordered : Boolean := false
      nrexchanges : NNI := 0
      n := #m
      while not wasordered repeat
        wasordered := true
        for i in 1..(n-1) repeat
          if f(m.(i+1), m.i) then
            swap!(m, i+1, i)
            nrexchanges := nrexchanges + 1
            wasordered := false
      [m, nrexchanges]

    if S has OrderedSet then
      bubbleSort!(m) == bubbleSort!(m, _<$S)
      insertionSort!(m) == insertionSort!(m, _<$S)
      countingBubbleSort(m) == countingBubbleSort(m, _<$S)
      countingBubbleSort!(m) == countingBubbleSort!(m, _<$S)

    if A has UnaryRecursiveAggregate(S) then
      -- Put the code here as we need first, rest functions which
      -- are not available for the general A defined above

      bubbleSort!(m, fn) ==
        empty? m => m
        l := m
        while not empty? (r := l.rest) repeat
           r := bubbleSort!(r, fn)
           x := l.first
           if fn(r.first, x) then
             l.first := r.first
             r.first := x
           l.rest := r
           l := l.rest
        m

      mergeSort(m, f) ==
        n : NNI := #m
        n <= 1 => m

        -- Split and descend
        na : NNI := shift(n, -1)
        nb : NNI := (n - na)::NNI
        sla := mergeSort(first(m,na), f)
        slb := mergeSort(rest(m,na), f)

        -- Merge
        result := copy m

        for i in 1..n repeat
          if #sla > 0 and #slb > 0 then
            fsla := first sla
            fslb := first slb
            if f(fsla, fslb) then
              result(i) := fsla
              sla := rest(sla)
            else
              result(i) := fslb
              slb := rest(slb)
          else if #sla > 0 then
            result(i) := first sla
            sla := rest(sla)
          else if #slb > 0 then
            result(i) := first slb
            slb := rest(slb)

        result


      if S has OrderedSet then
        mergeSort(m) == mergeSort(m, _<$S)


--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
